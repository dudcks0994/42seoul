# Projects of 42Seoul

## Minishell
과제 목표 : C99의 제한된 함수들을 이용해 기본적인 기능들을 가진 리눅스 쉘 프로그램 구현

#### heredoc
- 실제 bash는 input 데이터가 파이프 버퍼사이즈보다 작으면 그 안에 저장하는데, 실행파트의 구조상 임시파일로 넣는걸로 변경
- heredoc 실행 중 시그널은 부모프로세스에게도 전달이 되면 안되므로 부모프로세스에서 특정시그널 무시처리
- 입력이 끝나면 '<<' 토큰을 '<' 토큰으로 변경해 실행부에서 처리할수 있게 함
  - 임시파일을 리다이렉션으로 읽을 수 있게 처리
#### 환경변수
- export를 통해 환경변수 추가/수정 가능하게끔 환경변수 네이밍 규칙대로 파싱
- 쉘 안에서 프로그램 실행 시, 변경된 환경변수들 적용되게끔 기존 환경변수들을 리스트에따로 담아서 저장후, 실행시 환경변수 새로 만들기
- 일반 파싱 혹은 heredoc에서 환경변수입력시 치환할 수 있는 알고리즘 구현
  - 새로만들 문자열에 그대로 넣을 인덱스와 바꿀 환경변수의 이름의 인덱스를 두고 새로운 문자열을 할당해 반복문을 돌면서 치환
#### 시그널 처리
- 쉘 내에서 Ctrl+C 와 Ctrl+| 등의 동작이 일반 프로그램과 동작이 다르게끔 설정
- heredoc과 명령어 실행 등 자식프로세스를 만들 경우, return code는 자식의 종료코드이므로 signal전용 전역변수로 받아올수 있게끔 함
- 자식프로세스에서 받는 시그널이 부모프로세스에게 영향을 끼치지 않게 fork이전에 무시해야 함
#### 실행부
- 만들어진 토큰을 확인하면서 환경변수 치환 후, 다시 토큰화가 된다면 토큰화(bash)
- 리다이렉션 토큰 확인후 미리 fd확보, 예외처리(권한 및 I/O에러)
- 파이프가 존재 할 경우, 명령어 세트별로 리스트를 만든 뒤 프로그램, 인자, 리다이렉션 파일 fd 를 저장
- fork하면서 파이프 명령어 병렬실행, 파이프를 통해 각 프로세스들의 입력과 출력 연결
- 모든 프로세스들 waitpid로 회수 후 마지막 프로세스의 종료코드를 저장

### 배운 점
- 자식프로세스를 생성하는 heredoc이나 cmd실행에서, SIGINT 등을 했을때 다같이 종료되거나 표준입력이 이상해지는 현상
  - 시그널은 부모와 자식 모두에게 전달되기때문에, heredoc은 fork직후, cmd실행은 실행 직전(다른프로세스로 덮어씌워지므로)에 시그널을 무시하게 처리
- 천개 이상의 명령어가 파이프를 통해 잘 전달되게 하기 위한 IPC 기본 이해
  - 이전 파이프관련 과제에서는 명령어 갯수 -1 개만큼 파이프를 만들어서 데이터를 공유했으나, 운영체제에서 프로세스별 fd 최대 제한이 존재함
  - fork()시에 부모프로세스의 모든것이 복제되는 특성을 이용해 부모프로세스에서 최대2개의 파이프를 이용해 모든 자식프로세스들의 입출력을 연결함
- 스페이스 뿐 아니라 파이프 앞뒤로 문자와 붙어있거나 리다이렉션문자가 파일이름과 붙어있더라도 정상적으로 작동하는 이유는 메타캐릭터의 문자들을 기준으로 토큰화가 되어있기 때문
- heredoc 구현을 임시파일로 했을 때, 파일이름이 이미 존재할 경우 원본파일이 덮어씌워지므로 파일 유실이 될 수 있음
  - 해당 파일이름을 기준으로 뒤에 숫자를 1씩 증가시켜가며 존재유무를 파악해 중복 회피
- 입력이 존재하는 프로그램에서 상당수의 오류는 입력의 잘못된 파싱으로 인한 것이므로 파싱이 정말 중요함
- 명령어가 몇개나 들어올지, 들어올 문자열의 길이 등을 알수 없기 때문에 대부분 동적메모리 할당 및 사용완료시 해제로 누수 해결

## Webserv
과제목표 : C++98을 이용하여 기본적인 기능을 가진 웹서버 구현

#### HTTP 리퀘스트 파싱
- RFC 문서를 읽으면서 기본적인 HTTP 프로토콜에 대해 이해
- 스타트라인/헤더/바디 각 부분을 파싱해서 정보를 저장
  - 모든 줄이 CR(Carrige return) + LF(Line feed) 로 끝나는지 확인
  - 스타트라인에 들어가야 하는 요소들 유효성 검사, 헤더 유효성 검사 및 중복검사
  - Method에 따라 body의 파싱여부 판단, Content-Encoding의 타입에 따라 chunked 고려
  - 버퍼크기를 1024로 해둠에 따라, 각 리퀘스트의 완성여부와 에러여부 저장
#### Multiplexing I/O
- TCP 소켓을 이용하여 클라이언트와 HTTP 프로토콜을 이용해 소통하는데, 여러 클라이언트가 있을 수 있으므로 Multiplexing 방식으로 구현함
- kqueue,kevent 함수를 사용하여 이벤트가 발생해야만 read,write 함수가 호출 될 수 있음
- 클라이언트의 연결요청과 리퀘스트, cgi 실행 및 읽기, 리스폰스 보내기 모두 kevent 반복문에서 처리됌
- 리퀘스트가 chunked일 경우와 리퀘스트가 형식에 맞게 오다 멈출 경우, CGI 처리가 오래걸리거나 리스폰스 보낼때 시간이 오래걸리는 경우 TIMER 이벤트로 kevent 리턴 시 처리 가능
- 클라이언트와 연결된 소켓fd와 CGI일 때의 파이프fd, pid와 읽은 string, Response의 

#### CGI(php)
- CGI(Common Gateway Interface)에 대한 기본적인 이해와 RFC문서를 통해 구현 필수조건 확인
- 실행시간이 오래걸리거나 혹은 잘못된 CGI 프로그램으로 무한루프가 일어날 수 있으므로 kevent에 타이머이벤트를 등록
- 구현상 가장 간단한 방법은 임시파일에 리퀘스트의 Body를 넣고 자식프로세스를 통해 cgi 실행 후, 결과도 파일로 저장한 뒤 읽어오는것이 편하지만 과제 제약 상 모두 파이프로만 송수신 해야 함
- 파이프를 열고 읽기용 파이프를 kevent에 READ 이벤트로 등록 및 pid를 PROC 이벤트에 등록
- 구현한 환경에서의 파이프 최대버퍼사이즈만큼만 리퀘스트의 Body를 보내거나, 혹은 실행후의 데이터를 읽고 관련된 string 객체에 저장
- fcntl을 이용해 Non-Blocking 방식으로 읽고 씀으로써 보내거나 쓸 때만 이벤트가 발생하여 다른 예외를 막음(이벤트가 발생했을 때만 read/write하므로 Non-Blocking일때 확인해야하는 errno 확인필요x)
- kevent를 통해 이벤트와 fd로만 이뤄지므로, 어떤 리퀘스트에 대한것인지 알 수 있도록 map container를 활용해 연결고리를 만들어 자식프로세스의 pid와 파이프의 fd, string객체 모두 저장
- 대용량 데이터의 송수신일 때 복사가 이뤄지면 서버의 속도저하가 일어나므로 최대한 레퍼런스 연산자를 사용하여 복사생성자 호출 방지
- 쿼리스트링 및 Method와 PATH_INFO 등 필요한 인자를 환경변수로 직접 만들어 execve 사용시 인자로 넣음
- 실행 결과에서 리스폰스에 넣어야할 헤더가 있는 경우 파싱해서 헤더를 추가 혹은 변경
- 프로세스 이벤트가 일어나면 어떠한 식으로든 종료가 된 것이므로 종료코드를 확인 후 Response를 만들고 WRITE 이벤트를 등록

### 배운 점
- TCP/IP 소켓 통신에 대한 이해
  - 컴퓨터들끼리 네트워크상에서 소켓을 사용하여 통신하는 방법에 대한 이해
  - 바이트순서가 네트워크는 항상 빅엔디언으로 되어있음 -> 빅엔디언으로 바꿔주는 함수 존재
  - seige를 사용하여 단시간에 많은 연결로 서버부하 테스트 진행시, 어느순간부터 모든연결이 안되는 현상이 발생
    - TCP 소켓 연결 종료시, 원래는 남아있던 데이터를 전송하는데 이로인해 소켓연결이 완전히 닫히지않는 문제가 발생하여 so_linger 구조체로 즉시 데이터를 버리게 처리
  - 테스트 후 껏다가 다시켰을때 같은 포트로 열면 bind error가 발생
    - 실제 소켓을 close()하더라도 위와 같은 비슷한 이유로 소켓끼리 종료를 확인하고 주고받는데까지 시간이 걸려서 커널에서는 아직 해당 소켓이 존재하기에 에러가 발생
    - reuseaddr 옵션을 사용해 close()호출 이후 커널단에서 관리중인 포트를 재사용가능하게 처리
- HTTP 프로토콜에 대한 이해
  - RFC문서(https://datatracker.ietf.org/doc/html/rfc7230)를 통해 프로토콜 이해 및 문법 확인
  - 특정 브라우저로만 접속이 가능하다던가, 브라우저로만 다운로드가 가능하거나, 다운로드 가속기같이 분할 고속다운로드가 가능하거나 막는것이 어떻게 되어있을지 예상가능
  - 템플릿으로 테스트할 때, pending상태의 파일들일 자주 떴는데 Content-Length를 보내주지 않으면 브라우저가 해당 컨텐츠가 어디까지인지를 모름 -> 여러 헤더들이 하는 역할에 대해 이해
- Multiplexing I/O 모델
  - 서버는 여러 클라이언트(소켓fd)와 소통해야하는데, 멀티프로세스나 멀티쓰레드 방식 사용시 부하가 크고 느리며 컨텍스트 스위칭 비용으로 인해 입출력을 묶어서 관리하는 멀티플렉싱 방식으로 구현
  - Non-Blocking fd를 사용하여 이벤트가 있을때에만 kevent가 리턴되어 
- CGI 지원
  - CGI에 대한 이해
  - CGI를 처리하기 위해 fork사용 및 IPC 구현
- 클라이언트 리퀘스트 구문분석(Parse)
- 각종 예외처리를 위한 구조 고민
  - 타임아웃이 날 수 있는 부분들의 구분을 위해 맵 자료구조사용하여 연결
  - 정상적인 연결종료와 비정상 연결종료를 구분
 
## Philosopher
과제 목표 : C98의 제한된 함수들을 이용해 식사하는 철학자 문제 구현

#### 병행성
- 여러명의 철학자들이 각자 포크를 들거나 먹고 자는것이 동시에 이루어지기 위해서 멀티쓰레드와 멀티쓰레드를 사용하여 처리
- 식사를 하기위해 집어야 하는 포크가 쓰레드(프로세스)와 같은 포크여야 함(공유자원)
- 순서가 보장되지 않기에 데이터레이스가 일어날수 있어 뮤텍스를 사용해 임계구역을 만들어 원자적 실행 보장(혹은 멀티프로세스 시 세마포어)
- 시간순으로 각 철학자의 행동을 출력해야 하는데, 누군가 죽었을 때 출력이 멈춰야하고, 시간순서대로 출력이 나와야하므로 모든 출력부도 뮤텍스로 원자성 보장
- 철학자들의 죽음을 피해야하므로 데드락 발생을 막아야함
  - 각 포크의 사용상태를 변수로 두고 각각 뮤텍스를 만들어 확인할때 반드시 임계구역을 만들어서 확인후 집거나 포기하며, 한개를 들더라도 두개를 들수없다면 내려놓게끔 처리
  - 반드시 왼쪽 포크부터 집게끔 하고, 처음 프로그램 시작 시, 홀수번째 철학자들을 짝수번째 철학자들이 먼저 먹게끔 기다리게 처리
- 철학자 수가 많아지면서 컨텍스트 스위칭 횟수가 늘어날수록 시간 밀림현상이 증가하므로, 이를 위해 밥먹는 시간, 자는시간 등의 지연처리 시 해당 스레드를 확인하지 않게 usleep에 적당한 긴 시간을 줌
- 철학자를 fork를 사용해 멀티프로세스로 구현할 경우, 데이터공유가 IPC관련 함수를 사용할수 없기에 힘들어서, 먹는 횟수는 결국 싸이클 횟수와 같으므로 세마포어를 통해 카운팅

### 배운점
- sleep(usleep)의 매개변수 시간은 해당 프로세스(혹은 쓰레드)의 최소 실행유예시간을 보장한다 -> 정확히 그 시간이 지나고서의 실행이 보장되지 않음
- 컨텍스트 스위칭 자체에 PC,레지스터 값 변경 등에 따른 자원(시간)소모가 있어, 시간 밀림현상을 줄이기 위해 오히려 sleep(usleep)에 조금더 긴 시간을 주는것이 좋을 수 있음
- 운영체제에서 CPU가 프로세스를 다룰때 사용하는 PCB에 대한 개념 습득
- 컨텍스트 스위칭에 대한 단점 뿐 아니라, 쓰레드 혹은 프로세스를 만드는 것 자체도 시간이 걸리며 공유데이터를 관리하기위한 방법(뮤텍스,세마포어등을 통한 원자적실행과 IPC)이 까다롭다는 것
- 아파치보다 nginx가 더 커넥션 성능이 좋은 이유가, 멀티프로세스 혹은 멀티쓰레드를 사용할 경우 소모되는 자원과 시간으로 인해 싱글스레드 멀티플렉싱 방식을 선택한 것이라는 것
- 웹서버 프로그램들이 fast-cgi방식으로 바꾸게 된 이유를 알 수 있음
