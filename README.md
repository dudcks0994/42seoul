# Projects of 42Seoul

## Minishell
과제 목표 : C99의 제한된 함수들을 이용해 기본적인 기능들을 가진 리눅스 쉘 프로그램 구현

#### heredoc
- 실제 bash는 input 데이터가 파이프 버퍼사이즈보다 작으면 그 안에 저장하는데, 실행파트의 구조상 임시파일로 넣는걸로 변경
- heredoc 실행 중 시그널은 부모프로세스에게도 전달이 되면 안되므로 부모프로세스에서 특정시그널 무시처리
- 입력이 끝나면 '<<' 토큰을 '<' 토큰으로 변경해 실행부에서 처리할수 있게 함
  - 임시파일을 리다이렉션으로 읽을 수 있게 처리
#### 환경변수
- export를 통해 환경변수 추가/수정 가능하게끔 환경변수 네이밍 규칙대로 파싱
- 쉘 안에서 프로그램 실행 시, 변경된 환경변수들 적용되게끔 기존 환경변수들을 리스트에따로 담아서 저장후, 실행시 환경변수 새로 만들기
- 일반 파싱 혹은 heredoc에서 환경변수입력시 치환할 수 있는 알고리즘 구현
  - 새로만들 문자열에 그대로 넣을 인덱스와 바꿀 환경변수의 이름의 인덱스를 두고 새로운 문자열을 할당해 반복문을 돌면서 치환
#### 시그널 처리
- 쉘 내에서 Ctrl+C 와 Ctrl+| 등의 동작이 일반 프로그램과 동작이 다르게끔 설정
- heredoc과 명령어 실행 등 자식프로세스를 만들 경우, return code는 자식의 종료코드이므로 signal전용 전역변수로 받아올수 있게끔 함
- 자식프로세스에서 받는 시그널이 부모프로세스에게 영향을 끼치지 않게 fork이전에 무시해야 함
#### 실행부
- 만들어진 토큰을 확인하면서 환경변수 치환 후, 다시 토큰화가 된다면 토큰화(bash)
- 리다이렉션 토큰 확인후 미리 fd확보, 예외처리(권한 및 I/O에러)
- 파이프가 존재 할 경우, 명령어 세트별로 리스트를 만든 뒤 프로그램, 인자, 리다이렉션 파일 fd 를 저장
- fork하면서 파이프 명령어 병렬실행, 파이프를 통해 각 프로세스들의 입력과 출력 연결
- 모든 프로세스들 waitpid로 회수 후 마지막 프로세스의 종료코드를 저장

### 배운 점
- 시그널은 자식프로세스와 부모프로세스 모두에게 전달된다
- 천개 이상의 명령어가 파이프를 통해 잘 전달되게 하기 위한 IPC 기본 이해
- 어떤 입력이 들어오든 일관된 처리를 하기 위해 메타캐릭터를 알고 토크나이저를 잘 만들어야 한다
- 쉘에서 명령어 실행할 때, 자식프로세스를 만드는 방식이 하나의 자식이 나머지를 관리하는 방법도 존재한다
- 어떤 프로그램이 정상적으로 잘 작동하는 것에는 기본적으로 입력의 파싱이 완벽해야 한다

## Webserv
과제목표 : C++98을 이용하여 기본적인 기능을 가진 웹서버 구현

#### HTTP 리퀘스트 파싱
- RFC 문서를 읽으면서 기본적인 HTTP 프로토콜에 대해 이해
- 스타트라인/헤더/바디 각 부분을 파싱해서 정보를 저장
  - 모든 줄이 CR(Carrige return) + LF(Line feed) 로 끝나는지 확인
  - 스타트라인에 들어가야 하는 요소들 유효성 검사, 헤더 유효성 검사 및 중복검사
  - Method에 따라 body의 파싱여부 판단, Content-Encoding의 타입에 따라 chunked 고려
  - 버퍼크기를 1024로 해둠에 따라, 각 리퀘스트의 완성여부와 에러여부 저장
#### Multiplexing I/O
- TCP 소켓을 이용하여 클라이언트와 HTTP 프로토콜을 이용해 소통하는데, 여러 클라이언트가 있을 수 있으므로 Multiplexing 방식으로 구현함
- kqueue,kevent 함수를 사용하여 이벤트가 발생해야만 read,write 함수가 호출 될 수 있음
- 클라이언트의 연결요청과 리퀘스트, cgi 실행 및 읽기, 리스폰스 보내기 모두 kevent 반복문에서 처리됌
- 리퀘스트가 chunked일 경우와 리퀘스트가 형식에 맞게 오다 멈출 경우, CGI 처리가 오래걸리거나 리스폰스 보낼때 시간이 오래걸리는 경우 TIMER 이벤트로 kevent 리턴 시 처리 가능
- 클라이언트와 연결된 소켓fd와 CGI일 때의 파이프fd, pid와 읽은 string, Response의 

#### CGI(php)
- CGI(Common Gateway Interface)에 대한 기본적인 이해와 RFC문서를 통해 구현 필수조건 확인
- 실행시간이 오래걸리거나 혹은 잘못된 CGI 프로그램으로 무한루프가 일어날 수 있으므로 kevent에 타이머이벤트를 등록
- 구현상 가장 간단한 방법은 임시파일에 리퀘스트의 Body를 넣고 자식프로세스를 통해 cgi 실행 후, 결과도 파일로 저장한 뒤 읽어오는것이 편하지만 과제 제약 상 모두 파이프로만 송수신 해야 함
- 파이프를 열고 읽기용 파이프를 kevent에 READ 이벤트로 등록 및 pid를 PROC 이벤트에 등록
- 구현한 환경에서의 파이프 최대버퍼사이즈만큼만 리퀘스트의 Body를 보내거나, 혹은 실행후의 데이터를 읽고 관련된 string 객체에 저장
- fcntl을 이용해 Non-Blocking 방식으로 읽고 씀으로써 보내거나 쓸 때만 이벤트가 발생하여 다른 예외를 막음
- kevent를 통해 이벤트와 fd로만 이뤄지므로, 어떤 리퀘스트에 대한것인지 알 수 있도록 map container를 활용해 연결고리를 만들어 자식프로세스의 pid와 파이프의 fd, string객체 모두 저장
- 대용량 데이터의 송수신일 때 복사가 이뤄지면 서버의 속도저하가 일어나므로 최대한 레퍼런스 연산자를 사용하여 복사생성자 호출 방지
- 쿼리스트링 및 Method와 PATH_INFO 등 필요한 인자를 환경변수로 직접 만들어 execve 사용시 인자로 넣음
- 실행 결과에서 리스폰스에 넣어야할 헤더가 있는 경우 파싱해서 헤더를 추가 혹은 변경
- 프로세스 이벤트가 일어나면 어떠한 식으로든 종료가 된 것이므로 종료코드를 확인 후 Response를 만들고 WRITE 이벤트를 등록
- 

배운 점 : 
- TCP/IP 소켓 통신에 대한 이해
  - MultiPlexing I/O의 필요성 이해 및 지식 습득(클라이언트들과 소통하기위한 fd관리)
- RFC문서를 통해 규격 확인 및 이해
  - HTTP 프로토콜에 대한 이해 및 규칙 확인
- 웹 브라우저가 하는 일에 대한 이해
  - 리퀘스트 및 리스폰스에서 각 헤더들이 하는 역할에 대한 이해
- CGI 지원
  - CGI에 대한 이해
  - CGI를 처리하기 위해 fork사용 및 IPC 구현
- 클라이언트 리퀘스트 구문분석(Parse)
- 각종 예외처리를 위한 구조 고민
  - 타임아웃이 날 수 있는 부분들의 구분을 위해 맵 자료구조사용하여 연결
  - 정상적인 연결종료와 비정상 연결종료를 구분
  - 
